/*----------------------------------------------------------------
// Copyright (C) 2018 奇安信科技集团 版权所有。
//
// 文件名：Struct.proto
// 文件功能描述：数据结构定义
//
// 创建者：wangaibing@qianxin.com
// 时间：2021-07-23
//
// 版本：V1.0.0
//----------------------------------------------------------------*/
syntax = "proto3";

import "google/protobuf/timestamp.proto";
import "Struct.proto";

// QuickSSL gRPC API
//
// QuickSSL gRPC 接口服务提供密钥管理和密码服务
package quick.api.grpc.v1;

option java_multiple_files = true;
option java_outer_classname = "QuickCryptoStruct";
option java_package = "org.quick.api.grpc.v1";
option go_package = "quick/api/grpc/v1;apigrpcv1";
option optimize_for = CODE_SIZE;


//单步杂凑运算请求
message HashRequest {

    //杂凑运算类型
    HashType alg                  = 1;

    //当SM2和SM3算法配合使用时，计算摘要可以输入公钥
    oneof pubkey {

        //SM2公钥值
        ECCrefPublicKey key_value = 2;

        //SM2公钥ID
        string key_id             = 3;
    }

    //当SM2和SM3算法配合使用时，计算摘要可以输入用户ID
    string user_id                = 4;

    //被处理的数据
    bytes    data                 = 5;
}


//单步杂凑运算响应
message HashResponse {

    //服务执行情况
    Status status    = 1; 

    //杂凑运算得到的数字摘要
    bytes   digest   = 2;	
}


//多步杂凑运算初始化请求
message HashInitRequest{

    //杂凑运算类型
    HashType alg                  = 1;

    //当SM2和SM3算法配合使用时，计算摘要可以输入公钥
    oneof pubkey {

        //SM2公钥值
        ECCrefPublicKey key_value = 2;

        //SM2公钥ID
        string key_id             = 3;
    }

    //当SM2和SM3算法配合使用时，计算摘要可以输入用户ID
    string user_id                = 4;    
}


//多步杂凑运算初始化响应
message HashInitResponse {

    //服务执行情况
    Status status    = 1; 

    //杂凑运算上下文ID
    string  ctx_id   = 2;
}


//多步杂凑运算更新请求
message HashUpdateRequest {

    //杂凑运算上下文ID
    string  ctx_id    = 1;	

    //被处理的数据
    bytes   data      = 2;
}


//多步杂凑运算更新响应
message HashUpdateResponse {

    //服务执行情况
    Status status     = 1; 
}


//多步杂凑运算结果输出请求
message HashFinalRequest {

    //杂凑运算上下文ID	
    string  ctx_id    = 1;	
}


//多步杂凑运算结果输出响应
message HashFinalResponse {

    //服务执行情况
    Status status     = 1; 

    //杂凑运算得到的数字摘要
    bytes   digest    = 2;
}


//单步消息认证码运算请求
message MacRequest {

    oneof key {

        //消息认证码运算对称密钥ID
        string key_id          = 1;

        //消息认证码运算对称密钥值
        bytes unsafe_key_value = 2;
    }

    //消息认证码运算算法类型，默认为HMAC SM3 
    MacAlg alg                 = 3;

    //对称分组算法CBC模式初始向量，默认为0
    bytes iv                   = 4;

    //被处理的数据	
    bytes  data                = 5;
}


//单步消息认证码运算响应
message MacResponse {

    //服务执行情况
    Status status              = 1; 

    //运算得到的消息认证码
    bytes   mac                = 2;
}


//多步消息认证码运算初始化请求
message MacInitRequest {

    oneof key {

        //消息认证码运算对称密钥ID
        string key_id          = 1;

        //消息认证码运算对称密钥值
        bytes unsafe_key_value = 2;
    }

    //消息认证码运算算法类型，默认为HMAC SM3 
    MacAlg alg                 = 3;

    //对称分组算法CBC模式初始向量，默认为0
    bytes iv                   = 4;
}


//多步消息认证码运算初始化响应
message MacInitResponse {

    //服务执行情况
    Status status              = 1; 

    //消息认证码运算上下文ID
    string  ctx_id             = 2;	
}


//多步消息认证码运算更新请求
message MacUpdateRequest {

    //消息认证码运算上下文ID	
    string ctx_id             = 1;

    //被处理的数据	
    bytes  data               = 2;
}


//多步消息认证码运算更新响应
message MacUpdateResponse {

    //服务执行情况
    Status status             = 1; 
}


//多步消息认证码运算结果输出请求
message MacFinalRequest {

    //消息认证码运算上下文ID	
    string ctx_id             = 1;	
}


//多步消息认证码运算结果输出响应
message MacFinalResponse {

    //服务执行情况
    Status status = 1; 

    //运算得到的消息认证码	
    bytes   mac   = 2;
}


// 签名请求
message SignRequest {

    //签名算法
    SignAlg alg                  = 1;

    //ECC曲线
    ECCCurve curve               = 2;   

    //签名私钥
    oneof priv_key{

        //私钥ID
        string key_id            = 3;

        //RSA私钥值
        RSArefPrivateKey rsa_key = 4;
        
        //ECC私钥值
        ECCrefPrivateKey ecc_key = 5;
    }

    //签名结果格式
    SignFormat sign_format       = 6;

    //被签名数据
    bytes data                   = 7;
}


// 签名响应
message SignResponse {

    //服务执行情况
    Status status   = 1; 

    //签名值
    bytes signature = 2;
}

// 验签请求
message VerifyRequest {

    //验签算法类型
    SignAlg alg                  = 1;

    //ECC曲线
    ECCCurve curve               = 2;    

    //验签公钥
    oneof pub_key{

        //以公钥ID形式给出公钥
        string key_id            = 3;

        //以值的形式给出公钥
        string key_value         = 4;

        //以证书ID的形式给出公钥
        string cert_id           = 5;

        //以证书的形式给出公钥
        string cert_value        = 6;        
    }

    //被签名数据
    bytes data                   = 7;

    //签名格式
    SignFormat sign_format       = 8;

    //待验证的签名值
    bytes signature              = 9;
}

// 验签响应
message VerifyResponse {

    //服务执行情况
    Status status                = 1; 

    //验签结果
    bool result                  = 2;

}

// 接受者信息数据结构
message RecipientInfos {
    // 信封格式
    EvpFormat evp_format            = 1;
    // 信封版本，缺省为1
    int32 evp_version               = 2;
    //非对称加密公钥，即kek
    oneof kek {
        // 以公钥ID形式给出公钥
        string key_id               = 3;
        // 以值的形式给出公钥
        bytes key_value             = 4;
        // 以证书ID的形式给出公钥
        string cert_id              = 5;
        // 以证书的形式给出公钥
        string cert_value           = 6;
    }
    // 非对称加密算法，即kek适用的算法
    AsymmAlgo alg               = 7;
    // 如果使用RSA算法签名,需要选定填充模式
    RsaPaddingMode enc_padding     = 8;

}

// 信封加密请求
message EvpEncryptRequest {
    // 接受者信息的集合
    repeated RecipientInfos recipient_infos = 1;
    // 待加密明文
    bytes plain_text                        = 2;
    // 数据加密密钥，即dek
    oneof dek {
        // 以ID形式给出数据加密密钥
        string key_id                       = 3;
        // 以值的形式给出数据加密密钥
        bytes key_value                     = 4;
    }
    // 数据加密算法
    SymAlg alg                              = 5;
    // 填充模式
    SymAlgPaddingMode padding               = 6;
    // 加密参数
    SymAlgParam param                       = 7;
    // 签名请求参数
    SignRequest sign_request                = 8;
}

// 信封加密响应
message EvpEncryptResponse {
    // 服务执行情况
    Status status                = 1;
    // 运算得到的数字信封(带签名或者不带签名，可以有多张数字信封)
    repeated string envelops     = 2;
}

// 信封解密请求
message EvpDecryptRequest {
    // 数字信封
    string envelop = 1;
}

// 信封解密响应
message EvpDecryptResponse {
    // 服务执行情况
    Status status                = 1;
    // 解密得到的明文
    bytes plain_text             = 2;
}

//单步加密请求
message EncryptRequest {
    //加密算法
    SymAlg alg                   = 1;
    //加密密钥
    oneof symkey{
        //密钥ID
        string key_id            = 2;
        //密钥值
        bytes key_value          = 3;  
    }
    //填充模式
    SymAlgPaddingMode padding    = 4;
    //加密参数
    SymAlgParam param            = 5;
    //被加密数据
    bytes plain_text                   = 6;
}

// 单步加密应答
message EncryptResponse {
    //服务执行情况
    Status status    = 1;
    //加密后密文
    bytes cipher_text = 2;
}

//多步加密算初始化请求
message EncryptInitRequest{
    //加密算法
    SymAlg alg                   = 1;
    //加密密钥
    oneof symkey{
        //密钥ID
        string key_id            = 2;
        //密钥值
        bytes key_value          = 3;  
    }
    //填充模式
    SymAlgPaddingMode padding    = 4;
    //加密参数
    SymAlgParam param            = 5;
}

//多步加密运算初始化响应
message EncryptInitResponse {
    //服务执行情况
    Status status    = 1; 
    //加密运算上下文ID
    string  ctx_id   = 2;
}

//多步加密运算更新请求  
message EncryptUpdateRequest {
    //加密运算上下文ID
    string  ctx_id    = 1;	
    //被加密的数据
    bytes   plain_text      = 2;
}

//多步加密运算更新响应   
message EncryptUpdateResponse {
    //服务执行情况
    Status  status         = 1; 
    bytes   cipher_text    = 2;
}


//多步加密运算结果输出请求
message EncryptFinalRequest {
    //加密运算上下文ID	
    string  ctx_id    = 1;	
}


//多步加密运算结果输出响应
message EncryptFinalResponse {
    //服务执行情况
    Status  status         = 1; 
    //加密运算得到的密文
    bytes   cipher_text    = 2;
}


//单步解密请求
message DecryptRequest {
    //解密算法
    SymAlg alg                   = 1;
    //解密密钥
    oneof symkey{
        //密钥ID
        string key_id            = 2;
        //密钥值
        bytes key_value          = 3;  
    }
    //填充模式
    SymAlgPaddingMode padding    = 4;
    //解密参数
    SymAlgParam param            = 5;
    //被解密密文
    bytes cipher_text            = 6;  
}

// 单步解密应答
message DecryptResponse {
    //服务执行情况
    Status status    = 1;
    //解密后明文
    bytes plain_text = 2;   
}

//多步解密算初始化请求
message DecryptInitRequest{
    //解密算法
    SymAlg alg                   = 1;
    //解密密钥
    oneof symkey{
        //密钥ID
        string key_id            = 2;
        //密钥值
        bytes key_value          = 3;  
    }
    //填充模式
    SymAlgPaddingMode padding    = 4;
    //解密参数
    SymAlgParam param            = 5;
}

//多步解密运算初始化响应
message DecryptInitResponse {
    //服务执行情况
    Status status    = 1; 
    //解密运算上下文ID
    string  ctx_id   = 2;
}

//多步解密运算更新请求
message DecryptUpdateRequest {
    //解密运算上下文ID
    string  ctx_id    = 1;	
    //被解密的密文
    bytes   cipher_text    = 2;
}

//多步解密运算更新响应
message DecryptUpdateResponse {
    //服务执行情况
    Status  status        = 1;  
    //解密运算得到的明文
    bytes   plain_text    = 2;
}



//多步解密运算结果输出请求
message DecryptFinalRequest {
    //解密运算上下文ID	
    string  ctx_id    = 1;	
}



//多步解密运算结果输出响应
message DecryptFinalResponse {
    //服务执行情况
    Status  status        = 1; 
    //解密运算得到的明文
    bytes   plain_text    = 2;
}


//非对称加密请求
message AsymEncryptRequest {
    //非对称加密算法
    AsymmAlgo alg               = 1;
    //非对称加密公钥
    oneof pub_key{
        //以公钥ID形式给出公钥
        string key_id               = 2;
        //以值的形式给出公钥
        bytes key_value             = 3;
        //以证书ID的形式给出公钥
        string cert_id              = 4;
        //以证书的形式给出公钥
        string cert_value           = 5;  
    }
    // 如果使用RSA算法,需要选定填充模式
    RsaPaddingMode rsa_padding_mode = 6;
    // 被加密的明文
    bytes plain_text                = 7;
}

//非对称加密响应
message AsymEncryptResponse {
    //服务执行情况
    Status status                = 1;
    // 加密后的密文
    bytes  cipher_text           = 2;
}

//非对称解密请求
message AsymDecryptRequest {
    //非对称加密算法
    AsymmAlgo alg               = 1;
    //解密私钥
    oneof priv_key{
        //私钥ID
        string key_id               = 2;
        //RSA私钥值
        RSArefPrivateKey rsa_key    = 3;  
        //ECC私钥值
        ECCrefPrivateKey ecc_key    = 4;
    }
    // 如果使用RSA算法,需要选定填充模式
    RsaPaddingMode rsa_padding_mode = 5;
    // 被解密的密文
    bytes cipher_text               = 6;
}

//非对称解密响应
message AsymDecryptResponse {
    //服务执行情况
    Status status                = 1;
    // 解密后的
    bytes plain_text             = 2;
}

//封装密钥并导出请求
message WrapKeyRequest {
    //保护密钥算法
    oneof kek_algorithm{
        //对称算法类型
        SymAlg kek_sym_alg      = 1;
        //非对称算法类型
        AsymmAlgo kek_asymm_alg = 2;
    }
    //保护密钥, 支持证书ID、密钥ID（对称和非对称密钥）、外送证书、外送公钥
    oneof kek{
        //密钥ID
        string kek_id          = 3;
        //密钥值
        bytes kek_value        = 4;
        //以证书ID的形式给出公钥
        string cert_id         = 5;
        //以证书的形式给出公钥
        string cert_value      = 6;  
    }
    // 保护密钥如果使用RSA算法,需要选定填充模式
    RsaPaddingMode rsa_padding_mode    = 7;
    // 保护密钥如果使用对称算法,需要选定该填充模式
    SymAlgPaddingMode sym_padding_mode = 8;
    //如果算法类型为ECC，则需要指定椭圆曲线参数。
    ECCCurve curve                     = 9;    
    //被封装密钥
    oneof key{
        //密钥ID
        string key_id   = 10;
        //密钥值
        bytes key_value = 11;  
    }
}

//封装密钥并导出响应
message WrapKeyResponse {
    //服务执行情况
    Status status     = 1;
    // 加密后的密钥
    bytes wrapped_key = 2;
}

//导入并解封装密钥请求  
message UnwrapKeyRequest {
    //保护密钥算法
    oneof kek_algorithm{
        //对称算法类型
        SymAlg kek_sym_alg        = 1;
        //非对称算法类型
        AsymmAlgo kek_asymm_alg   = 2;
    }
    //保护密钥, 支持证书ID、密钥ID（对称和非对称密钥）
    oneof kek{
        //密钥ID
        string kek_id        = 3;
        //以证书ID的形式给出公钥
        string cert_id       = 4;
    }
    // 保护密钥如果使用RSA算法,需要选定填充模式
    RsaPaddingMode rsa_padding_mode    = 5;
    // 保护密钥如果使用对称算法,需要选定该填充模式
    SymAlgPaddingMode sym_padding_mode = 6;
    //如果算法类型为ECC，则需要指定椭圆曲线参数。
    ECCCurve curve                  = 7;    
    //被封装密钥
    bytes wrapped_key               = 8;
    //被封装密钥算法
    oneof algorithm{
        //对称算法类型
        SymAlg sym_alg        = 9;
        //非对称算法类型
        AsymmAlgo asymm_alg   = 10;
    }
    //密钥使用有效期，默认用后即销毁。
    KeyValidityTerm key_term = 11;
}

//导入并解封装密钥响应
message UnwrapKeyResponse {
    //服务执行情况
    Status status = 1;
    // 解封装后的密钥ID
    string key_id = 2;
}

//密钥协商参数
message AgreementParam {
    //参与密钥协商的发起方或响应方的身份标识 ID 值
    string id = 1;
    //ECC 公钥结构
    ECCrefPublicKey public_key    = 2;
    //临时 ECC 公钥结构
    ECCrefPublicKey tmp_public_key = 3;
    //密钥协商算法
    AgreementAlgo algo           = 4; 
    //要求协商的密钥长度
    int32  key_bits              = 5; 
}

//密钥协商产生密钥交换参数请求
message GenerateAgreementDataRequest {
    //密钥协商算法
    AgreementAlgo algo = 1;
    //密码设备内部存储加密私钥的索引值，该私钥用于参与密钥协商
    string prikey_id  = 2;
    //要求协商的密钥长度
    int32  key_bits   = 3;
    //参与密钥协商的发起方 ID 值
    string sponsor_id = 4;
}

//密钥协商产生密钥交换参数响应
message GenerateAgreementDataResponse {
    //服务执行情况
    Status status                 = 1;
    //返回的发起方ECC公钥参数
    AgreementParam  sponsor_param = 2;
    //返回的协商id，用于多步计算协商密钥
    string agreement_id           = 3;
}

//密钥协商产生密钥交换参数和key请求
message GenerateAgreementDataAndKeyRequest {
    //密码设备内部存储加密私钥的索引值，该私钥用于参与密钥协商
    string prikey_id              = 1;
    //参与密钥协商的响应方 ID 
    string response_id            = 2;
    //发起方 ECC 协商密钥参数
    AgreementParam  sponsor_param = 3;
}

//密钥协商产生密钥交换参数和key响应
message GenerateAgreementDataAndKeyResponse {
    //服务执行情况
    Status status                   = 1;
    //返回的响应方ECC协商密钥参数
    AgreementParam  responsor_param = 2;
    //返回的协商完成的密钥id
    string key_id                   = 3;
}

//密钥协商产生密钥key请求
message GenerateAgreementKeyRequest {
    //响应方ECC 协商密钥参数
    AgreementParam  responsor_param = 1;
    //协商id，在GenerateAgreementDataResponse的返回值
    string agreement_id             = 2;
}

//密钥协商产生密钥key响应
message GenerateAgreementKeyResponse {
    //服务执行情况
    Status status = 1;
    //返回的协商完成的密钥id
    string key_id = 2;
}

//**********************//
//防疫平台密码服务接口
//**********************//
//存储数据加密请求
message DataEncryptRequest {
    //密钥ID
    string key_id     = 1;
    //被加密数据
    bytes plain_text  = 2;
}

// 存储数据加密应答
message DataEncryptResponse {
    //服务执行情况
    Status status      = 1;
    //加密后密文base64编码
    string cipher_text = 2;
}
//存储数据解密请求
message DataDecryptRequest {
    oneof key_type {
        //存储数据密钥ID
        string key_id      = 1;
        //交换数据密钥ID
        string dek_id      = 2;
    }
    //被解密密文base64编码
    string cipher_text     = 3;  
}

// 存储数据解密应答
message DataDecryptResponse {
    //服务执行情况
    Status status    = 1;
    //解密后明文
    bytes plain_text = 2;   
}

// 信封加密请求
message EvpKeyEncryptRequest {
    // 加密数据密钥id
    string key_id       = 1;
    //对端加密证书id
    string peer_cert_id = 2;
}

// 信封加密响应
message EvpKeyEncryptResponse {
    // 服务执行情况
    Status status       = 1;
    // 运算得到的数字信封(带签名)
    string evp_text     = 2;
}
// 信封解密请求
message EvpKeyDecryptRequest {
    //对端签名证书id
    string peer_cert_id = 1;
    // 数字信封
    string evp_text     = 2;
}

// 信封解密响应
message EvpKeyDecryptResponse {
    // 服务执行情况
    Status status     = 1;
    // 解密交换数据密钥id
    string dek_id     = 2;
}

//**********************//
//防疫平台密码服务接口 end
//**********************//
    
